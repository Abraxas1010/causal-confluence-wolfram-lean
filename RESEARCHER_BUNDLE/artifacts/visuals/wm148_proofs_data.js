window.WM148_PROOFS = {"meta":{"generatedAt":"2025-12-27T23:42:54.311Z","seed":"wm148-umap-v1","vectorSignature":{"schema":"Φ/v1","weights":{"A":1,"B":0.7,"C":0.3,"D":0.2},"seed":"wm148-umap-v1","umap":"umap-js","pins":{"umap":"umap-js"},"providers":{},"digest":"f87c5ee803dee3ec5e3d82cdac1308f110a2072a717bc3a816128a5d583f73ca","phiDigest":"4b73c95bfa8f0a68a5f09fe268687277e1546db52551ff0c9bea6e2afdfa2316"},"source":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram (WM148 slice)","notes":"UMAP embedding of the WM148 causal-invariance development + demo."},"items":[{"id":"HeytingLean.WPP.Wolfram.WM148.P","name":"HeytingLean.WPP.Wolfram.WM148.P","kind":"abbrev","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":23,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":0,"length":24},"snippet":"abbrev P : Type := Fin 2","pos":{"x":0.059950003499881666,"y":0.6394815019740013},"pos3":{"x":0.7529740660553018,"y":0.03362402791956787,"z":0.9637882570565394}},{"id":"HeytingLean.WPP.Wolfram.WM148.V","name":"HeytingLean.WPP.Wolfram.WM148.V","kind":"abbrev","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":24,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":0,"length":23},"snippet":"abbrev V : Type := Nat\n","pos":{"x":0.02022596781711698,"y":0.6618271320449473},"pos3":{"x":0.7321589900303755,"y":0,"z":1}},{"id":"HeytingLean.WPP.Wolfram.WM148.rule","name":"HeytingLean.WPP.Wolfram.WM148.rule","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":26,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":4,"length":175},"snippet":"def rule : RuleFresh P where\n  nFresh := 1\n  lhs := ([[0, 1]] : List (Expr P))\n  rhs := ([[Sum.inl 0, Sum.inl 1], [Sum.inl 1, Sum.inr 0]] :\n      List (Expr (Sum P (Fin 1))))\n","pos":{"x":0.9474449491964857,"y":0.22550630347084658},"pos3":{"x":0.8988018442244531,"y":0.9408681163547133,"z":0.38324402811345204}},{"id":"HeytingLean.WPP.Wolfram.WM148.init","name":"HeytingLean.WPP.Wolfram.WM148.init","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":32,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":52},"snippet":"def init : HGraph V :=\n  ([[0, 0]] : List (Expr V))\n","pos":{"x":0.5733399396998635,"y":0.03954253839181319},"pos3":{"x":0.9372750564652572,"y":0.7499434118129336,"z":0.1219921822169836}},{"id":"HeytingLean.WPP.Wolfram.WM148.sys","name":"HeytingLean.WPP.Wolfram.WM148.sys","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":35,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":2,"parenDepth":0,"length":166},"snippet":"def sys : SystemFresh V P where\n  rules := [rule]\n  init := init\n\n@[simp] lemma sys_rules_length : sys.rules.length = 1 := by\n  simp [sys]","pos":{"x":0.05338338010066043,"y":0.6438154368622446},"pos3":{"x":0.7120725699734464,"y":0.028362436421717367,"z":0.9704767207165529}},{"id":"HeytingLean.WPP.Wolfram.WM148.rule_wellFormed","name":"HeytingLean.WPP.Wolfram.WM148.rule_wellFormed","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":44,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":3,"tactics":7,"parenDepth":1,"length":411},"snippet":"lemma rule_wellFormed : RuleFresh.WellFormed rule := by\n  intro p _hpRhs\n  refine ⟨[0, 1], by simp [rule], ?_⟩\n  cases p using Fin.cases with\n  | zero => simp\n  | succ p =>","pos":{"x":0.030523159500514218,"y":0.8031506184597578},"pos3":{"x":0.8339499078883976,"y":0.11134562816582416,"z":0.8763484954096187}},{"id":"HeytingLean.WPP.Wolfram.WM148.freshNat","name":"HeytingLean.WPP.Wolfram.WM148.freshNat","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":59,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":70},"snippet":"def freshNat (forbidden : Finset Nat) : Nat :=\n  forbidden.sup id + 1\n","pos":{"x":0.12938331956459803,"y":0.8427601863311458},"pos3":{"x":0.6842780936706981,"y":0.20574243182336446,"z":0.909517119698627}},{"id":"HeytingLean.WPP.Wolfram.WM148.freshNat_not_mem","name":"HeytingLean.WPP.Wolfram.WM148.freshNat_not_mem","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":62,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":4,"parenDepth":2,"length":604},"snippet":"lemma freshNat_not_mem (forbidden : Finset Nat) : freshNat forbidden ∉ forbidden := by\n  classical\n  intro hmem\n  have hle : freshNat forbidden ≤ forbidden.sup id := by\n    -- `freshNat forbidden ∈ forbidden` implies `freshNat forbidden ≤ sup`.\n    simpa [freshNat] using (Finset.le_sup (f := id) (s := forbidden) hmem)","pos":{"x":0.7111566316317944,"y":0.031887482290163305},"pos3":{"x":0.8642336695444363,"y":0.7582104507910918,"z":0}},{"id":"HeytingLean.WPP.Wolfram.WM148.allocFreshNat","name":"HeytingLean.WPP.Wolfram.WM148.allocFreshNat","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":74,"family":"WM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":0,"parenDepth":1,"length":110},"snippet":"def allocFreshNat (n : Nat) (forbidden : Finset Nat) : Fin n → Nat :=\n  fun i => (forbidden.sup id + 1) + i.1\n","pos":{"x":0.8320949359427251,"y":0.6952949388142361},"pos3":{"x":0.5370215871563085,"y":0.5636937385049864,"z":0.7336677214667973}},{"id":"HeytingLean.WPP.Wolfram.WM148.allocFreshNat_injective","name":"HeytingLean.WPP.Wolfram.WM148.allocFreshNat_injective","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":77,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":5,"parenDepth":1,"length":258},"snippet":"lemma allocFreshNat_injective (n : Nat) (forbidden : Finset Nat) :\n    Function.Injective (allocFreshNat n forbidden) := by\n  intro i j hij\n  apply Fin.ext\n  -- cancel the common prefix\n  have : i.1 = j.1 := by","pos":{"x":0.09481423615649552,"y":0.7825910045016893},"pos3":{"x":0.7488394359054389,"y":0.14816457248475398,"z":0.8770501157949776}},{"id":"HeytingLean.WPP.Wolfram.WM148.allocFreshNat_not_mem","name":"HeytingLean.WPP.Wolfram.WM148.allocFreshNat_not_mem","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":86,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":6,"parenDepth":2,"length":891},"snippet":"lemma allocFreshNat_not_mem (n : Nat) (forbidden : Finset Nat) (i : Fin n) :\n    allocFreshNat n forbidden i ∉ forbidden := by\n  classical\n  intro hmem\n  have hle : allocFreshNat n forbidden i ≤ forbidden.sup id := by\n    simpa using (Finset.le_sup (f := id) (s := forbidden) hmem)","pos":{"x":0.6663276451940087,"y":0},"pos3":{"x":0.9000152404862877,"y":0.7956388839751027,"z":0.0011026383196039566}},{"id":"HeytingLean.WPP.Wolfram.WM148.idx0","name":"HeytingLean.WPP.Wolfram.WM148.idx0","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":107,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":1,"parenDepth":1,"length":124},"snippet":"def idx0 : Fin sys.rules.length :=\n  ⟨0, by simp [sys]⟩\n\n/-- Build an event for the unique rule, from a substitution `σ`. -/","pos":{"x":0.10714980928122103,"y":0.7682808299546615},"pos3":{"x":0.790055461753559,"y":0.2719171718776378,"z":0.8413866538594578}},{"id":"HeytingLean.WPP.Wolfram.WM148.mkEvent","name":"HeytingLean.WPP.Wolfram.WM148.mkEvent","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":111,"family":"WM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":1,"parenDepth":1,"length":168},"snippet":"def mkEvent (σ : P → V) : sys.Event :=\n  { idx := idx0, σ := σ }\n\n/-- Deterministically apply an event, allocating fresh vertices as `allocFreshNat` above `verts s`. -/","pos":{"x":0.8147779391062524,"y":0.6623032001073565},"pos3":{"x":0.5789220976722929,"y":0.5918317991458028,"z":0.7485395103907082}},{"id":"HeytingLean.WPP.Wolfram.WM148.applyDet","name":"HeytingLean.WPP.Wolfram.WM148.applyDet","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148.lean","line":115,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":3,"length":178},"snippet":"def applyDet (e : sys.Event) (s : HGraph V) : HGraph V :=\n  e.applyWith (allocFreshNat e.rule.nFresh (HGraph.verts (V := V) s)) s\n\nend WM148\n\nend Wolfram","pos":{"x":0.9439299623324527,"y":0.19441503120682233},"pos3":{"x":0.9606954248371117,"y":0.9637548585326213,"z":0.2900784747954987}},{"id":"HeytingLean.WPP.Wolfram.WM148.expr_rename_eq_self_of_forall_mem","name":"HeytingLean.WPP.Wolfram.WM148.expr_rename_eq_self_of_forall_mem","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":35,"family":"WM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":2,"exists":0,"eq":7,"tactics":8,"parenDepth":1,"length":458},"snippet":"private lemma expr_rename_eq_self_of_forall_mem {V : Type} (f : V → V) (e : Expr V)\n    (h : ∀ x ∈ e, f x = x) : Expr.rename f e = e := by\n  induction e with\n  | nil =>\n      simp [Expr.rename]\n  | cons a e ih =>","pos":{"x":0.6762210267589696,"y":0.9903326763223801},"pos3":{"x":0,"y":0.6517830110654137,"z":0.5704008772634817}},{"id":"HeytingLean.WPP.Wolfram.WM148.hgraph_rename_eq_self_of_forall_mem","name":"HeytingLean.WPP.Wolfram.WM148.hgraph_rename_eq_self_of_forall_mem","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":48,"family":"WM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":2,"exists":0,"eq":9,"tactics":10,"parenDepth":1,"length":654},"snippet":"private lemma hgraph_rename_eq_self_of_forall_mem {V : Type} (f : V → V) (g : HGraph V)\n    (h : ∀ e ∈ g, Expr.rename f e = e) : HGraph.rename f g = g := by\n  classical\n  induction g using Multiset.induction_on with\n  | empty =>\n      simp [HGraph.rename]","pos":{"x":0.7270579619011952,"y":0.9639978353577402},"pos3":{"x":0.026835491341052883,"y":0.7033602013988624,"z":0.5870854217216535}},{"id":"HeytingLean.WPP.Wolfram.WM148.hgraph_rename_eq_self_of_fix_verts","name":"HeytingLean.WPP.Wolfram.WM148.hgraph_rename_eq_self_of_fix_verts","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":66,"family":"WM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":1,"exists":0,"eq":2,"tactics":6,"parenDepth":2,"length":435},"snippet":"private lemma hgraph_rename_eq_self_of_fix_verts {V : Type} [DecidableEq V] (f : V → V) (s : HGraph V)\n    (hfix : ∀ x ∈ HGraph.verts (V := V) s, f x = x) : HGraph.rename f s = s := by\n  apply hgraph_rename_eq_self_of_forall_mem (f := f) (g := s)\n  intro e he\n  apply expr_rename_eq_self_of_forall_mem (f := f) (e := e)\n  intro x hx","pos":{"x":0.8617127318985338,"y":0.8922061348005392},"pos3":{"x":0.24126514632955054,"y":0.8138350169294208,"z":0.5201661712362543}},{"id":"HeytingLean.WPP.Wolfram.WM148.multiset_foldl_singleton","name":"HeytingLean.WPP.Wolfram.WM148.multiset_foldl_singleton","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":75,"family":"WM148","features":{"implies":2,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":0,"parenDepth":1,"length":169},"snippet":"private lemma multiset_foldl_singleton {α β : Type} (f : β → α → β) [RightCommutative f] (b : β) (a : α) :\n    Multiset.foldl f b ({a} : Multiset α) = f b a := by\n  rfl\n","pos":{"x":0.9317630973570094,"y":0.6688657944690733},"pos3":{"x":0.5265420416742609,"y":0.7453690479679368,"z":0.7755610876973262}},{"id":"HeytingLean.WPP.Wolfram.WM148.verts_add_singleton","name":"HeytingLean.WPP.Wolfram.WM148.verts_add_singleton","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":79,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":1,"parenDepth":2,"length":552},"snippet":"private lemma verts_add_singleton {V : Type} [DecidableEq V] (g : HGraph V) (e : Expr V) :\n    HGraph.verts (V := V) (g + ({e} : HGraph V)) = HGraph.verts (V := V) g ∪ e.toFinset := by\n  classical\n  -- `verts` is a commutative `foldl`, so `verts (g + {e})` is `verts g` union the vertices of `e`.\n  simp [HGraph.verts, Multiset.foldl_add, multiset_foldl_singleton, HGraph.vertsStep]\n","pos":{"x":0.7062570008046082,"y":0.07683384053952479},"pos3":{"x":0.9194564372746478,"y":0.7239280485254455,"z":0.018043230846671615}},{"id":"HeytingLean.WPP.Wolfram.WM148.wm148_rule_eq","name":"HeytingLean.WPP.Wolfram.WM148.wm148_rule_eq","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":92,"family":"WM148","features":{"implies":0,"not":0,"and":1,"or":0,"forall":0,"exists":0,"eq":5,"tactics":11,"parenDepth":1,"length":545},"snippet":"private lemma wm148_rule_eq (e : sys.Event) : e.rule = rule := by\n  -- `sys.rules = [rule]`, and `e.idx : Fin 1`, so the only possible `get` is `rule`.\n  have hlen : sys.rules.length = 1 := by\n    simp [sys]\n  have hlt : (e.idx : Nat) < 1 :=\n    lt_of_lt_of_eq e.idx.isLt hlen","pos":{"x":0.2364833603560172,"y":0.811972871220491},"pos3":{"x":0.687563480884824,"y":0.20462396549621817,"z":0.759976480752525}},{"id":"HeytingLean.WPP.Wolfram.WM148.wm148_nFresh","name":"HeytingLean.WPP.Wolfram.WM148.wm148_nFresh","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":107,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":0,"parenDepth":2,"length":141},"snippet":"private lemma wm148_nFresh (e : sys.Event) : e.rule.nFresh = 1 := by\n  simpa [rule] using congrArg RuleFresh.nFresh (wm148_rule_eq (e := e))\n","pos":{"x":0.6144738679213865,"y":0.07506868068065234},"pos3":{"x":0.9373967115391544,"y":0.7015523112730142,"z":0.10453978393715897}},{"id":"HeytingLean.WPP.Wolfram.WM148.fresh0","name":"HeytingLean.WPP.Wolfram.WM148.fresh0","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":110,"family":"WM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":4,"parenDepth":2,"length":218},"snippet":"private def fresh0 (e : sys.Event) : Fin e.rule.nFresh :=\n  ⟨0, by\n    have hn : e.rule.nFresh = 1 := wm148_nFresh (e := e)\n    -- Avoid `simp`: it can rewrite `0 < 1` to `True`.\n    rw [hn]\n    exact Nat.zero_lt_one⟩","pos":{"x":0.6081980867472013,"y":0.017777730359778685},"pos3":{"x":1,"y":0.7750311093151322,"z":0.04795861163852176}},{"id":"HeytingLean.WPP.Wolfram.WM148.input_eq_singleton","name":"HeytingLean.WPP.Wolfram.WM148.input_eq_singleton","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":117,"family":"WM148","features":{"implies":0,"not":1,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":1,"parenDepth":1,"length":357},"snippet":"private lemma input_eq_singleton (e : sys.Event) :\n    e.input (sys := sys) = ({[e.σ 0, e.σ 1]} : HGraph Nat) := by\n  classical\n  -- Keep `e.rule` intact (do not unfold it to `sys.rules.get ...`) so we can rewrite it.\n  simp [-SystemFresh.Event.rule, SystemFresh.Event.input, RuleFresh.instLhs, wm148_rule_eq (e := e),\n    rule, HGraph.rename, Expr.rename]","pos":{"x":0.04544780962294172,"y":0.7526553121698845},"pos3":{"x":0.7030577967105623,"y":0.335476506069132,"z":0.8600604039533175}},{"id":"HeytingLean.WPP.Wolfram.WM148.instRhs_eq_input_add_new","name":"HeytingLean.WPP.Wolfram.WM148.instRhs_eq_input_add_new","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":124,"family":"WM148","features":{"implies":1,"not":0,"and":1,"or":0,"forall":0,"exists":0,"eq":7,"tactics":11,"parenDepth":3,"length":1093},"snippet":"private lemma instRhs_eq_input_add_new (e : sys.Event) (τ : Fin e.rule.nFresh → Nat) :\n    e.rule.instRhs e.σ τ =\n      e.input (sys := sys) + ({[e.σ 1, τ (fresh0 (e := e))]} : HGraph Nat) := by\n  classical\n  -- We cannot use numerals for `Fin sys.rules.length`, so we case-split on the unique rule index.\n  cases e with","pos":{"x":0.8639646274067911,"y":0.3917887422775639},"pos3":{"x":0.7581435807528958,"y":0.8738567560437777,"z":0.5403187002955853}},{"id":"HeytingLean.WPP.Wolfram.WM148.applyWith_eq_add_new","name":"HeytingLean.WPP.Wolfram.WM148.applyWith_eq_add_new","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":149,"family":"WM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":6,"tactics":4,"parenDepth":4,"length":1305},"snippet":"private lemma applyWith_eq_add_new (e : sys.Event) (τ : Fin e.rule.nFresh → Nat) (s : HGraph Nat)\n    (happ : e.Applicable (sys := sys) s) :\n    e.applyWith (sys := sys) τ s =\n      s + ({[e.σ 1, τ (fresh0 (e := e))]} : HGraph Nat) := by\n  classical\n  have hcancel : s - e.input (sys := sys) + e.input (sys := sys) = s := Multiset.sub_add_cancel happ","pos":{"x":0.8926731915360097,"y":0.29794339575348944},"pos3":{"x":0.8124701671874061,"y":0.914469010610749,"z":0.47044076920724776}},{"id":"HeytingLean.WPP.Wolfram.WM148.causalInvariant","name":"HeytingLean.WPP.Wolfram.WM148.causalInvariant","kind":"theorem","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/WM148CausalInvariant.lean","line":179,"family":"WM148","features":{"implies":4,"not":1,"and":6,"or":9,"forall":0,"exists":0,"eq":69,"tactics":231,"parenDepth":3,"length":19731},"snippet":"theorem causalInvariant : SystemFresh.CausalInvariant (sys := sys) := by\n  classical\n  intro a b c hab hac\n  rcases hab with ⟨e1, τ1, happ1, hfresh1, rfl⟩\n  rcases hac with ⟨e2, τ2, happ2, hfresh2, rfl⟩\n","pos":{"x":0.6254842287054807,"y":0.9135727504616221},"pos3":{"x":0.15423955190620395,"y":0.6208009789952827,"z":0.6682990945286214}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.StepWith","name":"HeytingLean.WPP.Wolfram.SystemFresh.StepWith","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/CausalInvarianceSingleLHS.lean","line":37,"family":"SystemFresh","features":{"implies":1,"not":0,"and":2,"or":0,"forall":0,"exists":2,"eq":1,"tactics":0,"parenDepth":1,"length":208},"snippet":"def StepWith (s t : HGraph V) : Prop :=\n  ∃ e : sys.Event,\n    ∃ τ : Fin (e.rule.nFresh) → V,\n      e.Applicable s ∧ e.FreshAssign τ s ∧ e.applyWith τ s = t\n\n/-- Reflexive–transitive closure of `StepWith`. -/","pos":{"x":0.5857936302621763,"y":0.7879157439391405},"pos3":{"x":0.39468200323888936,"y":0.47992782199450557,"z":0.6098227669139549}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.StepStarWith","name":"HeytingLean.WPP.Wolfram.SystemFresh.StepStarWith","kind":"abbrev","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/CausalInvarianceSingleLHS.lean","line":43,"family":"SystemFresh","features":{"implies":2,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":229},"snippet":"abbrev StepStarWith : HGraph V → HGraph V → Prop :=\n  Relation.ReflTransGen (StepWith (sys := sys))\n\n/-! ## Branch resolution up to vertex renaming -/\n\n/-- Two states are *joinable* if they can be evolved to isomorphic states. -/","pos":{"x":1,"y":0.6200192551472342},"pos3":{"x":0.5187401564160966,"y":0.8451174737966103,"z":0.7326119656193233}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.JoinableIso","name":"HeytingLean.WPP.Wolfram.SystemFresh.JoinableIso","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/CausalInvarianceSingleLHS.lean","line":49,"family":"SystemFresh","features":{"implies":0,"not":0,"and":2,"or":0,"forall":0,"exists":1,"eq":0,"tactics":0,"parenDepth":1,"length":246},"snippet":"def JoinableIso (b c : HGraph V) : Prop :=\n  ∃ d₁ d₂,\n    StepStarWith (sys := sys) b d₁ ∧\n    StepStarWith (sys := sys) c d₂ ∧\n    HGraph.Iso d₁ d₂\n","pos":{"x":0.29157497239525315,"y":0.7943383866675229},"pos3":{"x":0.6058022556153291,"y":0.21413193218764873,"z":0.7352219807180328}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.BranchResolves","name":"HeytingLean.WPP.Wolfram.SystemFresh.BranchResolves","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/CausalInvarianceSingleLHS.lean","line":56,"family":"SystemFresh","features":{"implies":2,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":244},"snippet":"def BranchResolves (a b c : HGraph V) : Prop :=\n  StepWith (sys := sys) a b →\n  StepWith (sys := sys) a c →\n  JoinableIso (sys := sys) b c\n\n/-- **Causal invariance** (Wolfram Physics / \"branch-pair resolution\"): every one-step fork resolves. -/","pos":{"x":0.9066740649859433,"y":0.6403307779976851},"pos3":{"x":0.49591697355402964,"y":0.7221511246132143,"z":0.7499807675392733}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.CausalInvariant","name":"HeytingLean.WPP.Wolfram.SystemFresh.CausalInvariant","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/CausalInvarianceSingleLHS.lean","line":62,"family":"SystemFresh","features":{"implies":2,"not":0,"and":0,"or":0,"forall":1,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":180},"snippet":"def CausalInvariant : Prop :=\n  ∀ a b c, StepWith (sys := sys) a b → StepWith (sys := sys) a c → JoinableIso (sys := sys) b c\n\nend SystemFresh\n\nend Wolfram","pos":{"x":0.9346882832817315,"y":0.7626805805430962},"pos3":{"x":0.33378924079282074,"y":0.7954753624729377,"z":0.6894886771944819}},{"id":"HeytingLean.WPP.Wolfram.FreshSupply.allocList","name":"HeytingLean.WPP.Wolfram.FreshSupply.allocList","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/FreshSupply.lean","line":35,"family":"FreshSupply","features":{"implies":2,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":5,"tactics":3,"parenDepth":2,"length":425},"snippet":"noncomputable def allocList : Nat → Finset V → List V\n  | 0, _forbidden => []\n  | n + 1, forbidden =>\n      let v := FreshSupply.fresh forbidden\n      v :: allocList n (insert v forbidden)\n","pos":{"x":0.991118098701401,"y":0.6074882943792919},"pos3":{"x":0.5782677333430483,"y":0.8262262781633636,"z":0.7600715110633086}},{"id":"HeytingLean.WPP.Wolfram.FreshSupply.allocList_mem_not_mem_forbidden","name":"HeytingLean.WPP.Wolfram.FreshSupply.allocList_mem_not_mem_forbidden","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/FreshSupply.lean","line":48,"family":"FreshSupply","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":3,"tactics":7,"parenDepth":2,"length":650},"snippet":"lemma allocList_mem_not_mem_forbidden {n : Nat} {forbidden : Finset V} {v : V} :\n    v ∈ allocList (V := V) n forbidden → v ∉ forbidden := by\n  classical\n  induction n generalizing forbidden with\n  | zero =>\n      intro hv","pos":{"x":0.8799392080775841,"y":0.5156385013223548},"pos3":{"x":0.6880099747685853,"y":0.820827454744598,"z":0.6690565339992105}},{"id":"HeytingLean.WPP.Wolfram.FreshSupply.allocList_nodup","name":"HeytingLean.WPP.Wolfram.FreshSupply.allocList_nodup","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/FreshSupply.lean","line":65,"family":"FreshSupply","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":2,"tactics":6,"parenDepth":3,"length":712},"snippet":"lemma allocList_nodup (n : Nat) (forbidden : Finset V) :\n    (allocList (V := V) n forbidden).Nodup := by\n  classical\n  induction n generalizing forbidden with\n  | zero =>\n      simp [allocList]","pos":{"x":0.895973397685698,"y":0.19989194494569645},"pos3":{"x":0.8578024609034807,"y":0.983366266143524,"z":0.3591862201223678}},{"id":"HeytingLean.WPP.Wolfram.FreshSupply.allocVec","name":"HeytingLean.WPP.Wolfram.FreshSupply.allocVec","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/FreshSupply.lean","line":83,"family":"FreshSupply","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":219},"snippet":"noncomputable def allocVec (n : Nat) (forbidden : Finset V) : List.Vector V n :=\n  ⟨allocList (V := V) n forbidden, allocList_length (V := V) n forbidden⟩\n\n/-- The corresponding fresh assignment function `Fin n → V`. -/","pos":{"x":0.89256353847876,"y":0.5258804716762412},"pos3":{"x":0.6170048667005846,"y":0.7816770123269037,"z":0.629773977491771}},{"id":"HeytingLean.WPP.Wolfram.FreshSupply.alloc","name":"HeytingLean.WPP.Wolfram.FreshSupply.alloc","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/FreshSupply.lean","line":87,"family":"FreshSupply","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":110},"snippet":"noncomputable def alloc (n : Nat) (forbidden : Finset V) : Fin n → V :=\n  (allocVec (V := V) n forbidden).get\n","pos":{"x":0.813119238806985,"y":0.5515226864568147},"pos3":{"x":0.6638160477058697,"y":0.7391814064348496,"z":0.6955228193647381}},{"id":"HeytingLean.WPP.Wolfram.FreshSupply.alloc_injective","name":"HeytingLean.WPP.Wolfram.FreshSupply.alloc_injective","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/FreshSupply.lean","line":90,"family":"FreshSupply","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":2,"parenDepth":2,"length":313},"snippet":"lemma alloc_injective (n : Nat) (forbidden : Finset V) :\n    Function.Injective (alloc (V := V) n forbidden) := by\n  classical\n  have hnodup : (allocVec (V := V) n forbidden).toList.Nodup := by\n    simpa [allocVec] using allocList_nodup (V := V) n forbidden\n  exact (List.Vector.nodup_iff_injective_get).1 hnodup","pos":{"x":0.6417783217879183,"y":0.022886193540418057},"pos3":{"x":0.9264918849981509,"y":0.7665114510759422,"z":0.07807748619872162}},{"id":"HeytingLean.WPP.Wolfram.FreshSupply.alloc_not_mem","name":"HeytingLean.WPP.Wolfram.FreshSupply.alloc_not_mem","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/FreshSupply.lean","line":97,"family":"FreshSupply","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":2,"parenDepth":3,"length":844},"snippet":"lemma alloc_not_mem (n : Nat) (forbidden : Finset V) (i : Fin n) :\n    alloc (V := V) n forbidden i ∉ forbidden := by\n  have hi : alloc (V := V) n forbidden i ∈ allocList (V := V) n forbidden := by\n    -- `Vector.get_mem` gives membership in the underlying list.\n    simpa [alloc, allocVec] using (List.Vector.get_mem i (allocVec (V := V) n forbidden))\n  exact allocList_mem_not_mem_forbidden (V := V) (n := n) (forbidden := forbidden) (v := alloc (V := V) n forbidden i) hi","pos":{"x":0.9137909909896658,"y":0.18085630529370497},"pos3":{"x":0.9150983374086517,"y":1,"z":0.3427533995927684}},{"id":"HeytingLean.WPP.Wolfram.RuleFresh","name":"HeytingLean.WPP.Wolfram.RuleFresh","kind":"structure","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":29,"family":"RuleFresh","features":{"implies":3,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":2,"parenDepth":2,"length":498},"snippet":"structure RuleFresh (P : Type u) where\n  nFresh : Nat\n  lhs : HGraph P\n  rhs : HGraph (Sum P (Fin nFresh))\n\nnamespace RuleFresh","pos":{"x":0.9976048147850233,"y":0.6575615347605698},"pos3":{"x":0.5147046447690259,"y":0.8329826112819814,"z":0.7711988042091654}},{"id":"HeytingLean.WPP.Wolfram.RuleFresh.WellFormed","name":"HeytingLean.WPP.Wolfram.RuleFresh.WellFormed","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":44,"family":"RuleFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":1,"exists":2,"eq":0,"tactics":0,"parenDepth":2,"length":210},"snippet":"def WellFormed {P : Type u} (r : RuleFresh P) : Prop :=\n  ∀ p : P, (∃ e ∈ r.rhs, (Sum.inl p) ∈ e) → (∃ e ∈ r.lhs, p ∈ e)\n\nend RuleFresh\n\n/-- A Wolfram-model system with fresh-vertex rules (SetReplace-style). -/","pos":{"x":0.661583869983677,"y":0.805882135115859},"pos3":{"x":0.2831937791677252,"y":0.5819727076770834,"z":0.5489860182732887}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh","name":"HeytingLean.WPP.Wolfram.SystemFresh","kind":"structure","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":50,"family":"SystemFresh","features":{"implies":0,"not":0,"and":1,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":269},"snippet":"structure SystemFresh (V : Type u) (P : Type v) where\n  rules : List (RuleFresh P)\n  init : HGraph V\n\nnamespace SystemFresh\n","pos":{"x":0.243733891429569,"y":0.8012517922379393},"pos3":{"x":0.65815452798985,"y":0.14875315225122918,"z":0.7994038530438848}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event","kind":"structure","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":59,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":2,"parenDepth":1,"length":403},"snippet":"structure Event (sys : SystemFresh V P) where\n  idx : Fin sys.rules.length\n  σ : P → V\n\nnamespace Event\n","pos":{"x":0.799054970344822,"y":0.6935679452301051},"pos3":{"x":0.5624744172627567,"y":0.5857242718942207,"z":0.7078820975310751}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.FreshAssign","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.FreshAssign","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":75,"family":"SystemFresh","features":{"implies":2,"not":0,"and":1,"or":0,"forall":1,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":425},"snippet":"def FreshAssign [DecidableEq V] (e : sys.Event) (τ : Fin (e.rule.nFresh) → V) (s : HGraph V) : Prop :=\n  Function.Injective τ ∧ ∀ i, τ i ∉ HGraph.verts (V := V) s\n\ninstance [DecidableEq V] (e : sys.Event) (τ : Fin (e.rule.nFresh) → V) (s : HGraph V) :\n    Decidable (e.FreshAssign τ s) := by\n  classical","pos":{"x":0.9107592586227485,"y":0.8201243086766994},"pos3":{"x":0.27131065126124526,"y":0.7992797268659617,"z":0.6421638018618454}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.Applicable","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.Applicable","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":85,"family":"SystemFresh","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":310},"snippet":"def Applicable (e : sys.Event) (s : HGraph V) : Prop :=\n  e.input ≤ s\n\ninstance decidableApplicable [DecidableEq V] (e : sys.Event) (s : HGraph V) :\n    Decidable (e.Applicable s) := by\n  dsimp [Applicable]","pos":{"x":0.12397444791418073,"y":0.8255067294606032},"pos3":{"x":0.7049506275638349,"y":0.2136808221173928,"z":0.9213837993880637}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":96,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":234},"snippet":"def applyWith (e : sys.Event) (τ : Fin (e.rule.nFresh) → V) (s : HGraph V) : HGraph V :=\n  s - e.input + (e.rule).instRhs e.σ τ\n\n/-- Apply the event using a `FreshSupply`, allocating fresh vertices from the current state's support. -/","pos":{"x":0.8070077129652552,"y":0.50894657705049},"pos3":{"x":0.6814766914733313,"y":0.7634039360937059,"z":0.6331065626158698}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.apply","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.apply","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":100,"family":"SystemFresh","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":1,"parenDepth":3,"length":228},"snippet":"noncomputable def apply (e : sys.Event) [FreshSupply V] (s : HGraph V) : HGraph V :=\n  e.applyWith (FreshSupply.alloc (V := V) (e.rule.nFresh) (HGraph.verts (V := V) s)) s\n\n/-- Fresh-supply allocation satisfies `FreshAssign`. -/","pos":{"x":0.9498470148126357,"y":0.17304226494561062},"pos3":{"x":0.9243910461623532,"y":0.9474607710920784,"z":0.2931754180068878}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.freshAssign_alloc","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.freshAssign_alloc","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":104,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":2,"parenDepth":3,"length":348},"snippet":"lemma freshAssign_alloc [FreshSupply V] (e : sys.Event) (s : HGraph V) :\n    e.FreshAssign (FreshSupply.alloc (V := V) (e.rule.nFresh) (HGraph.verts (V := V) s)) s := by\n  refine ⟨FreshSupply.alloc_injective (V := V) _ _, ?_⟩\n  intro i\n  exact FreshSupply.alloc_not_mem (V := V) _ _ i\n","pos":{"x":0.8436476426714817,"y":0.45770120492777394},"pos3":{"x":0.693295514566367,"y":0.8004034035026705,"z":0.5849995220868068}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.rangeFinset","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.rangeFinset","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":111,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":97},"snippet":"def rangeFinset {n : Nat} (τ : Fin n → V) : Finset V :=\n  (Finset.univ : Finset (Fin n)).image τ\n","pos":{"x":0.8452261523289244,"y":0.5545430418228219},"pos3":{"x":0.7128680199002222,"y":0.7264891304796377,"z":0.6762111813707853}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.mem_rangeFinset","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.mem_rangeFinset","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":114,"family":"SystemFresh","features":{"implies":1,"not":1,"and":1,"or":0,"forall":0,"exists":0,"eq":0,"tactics":2,"parenDepth":1,"length":247},"snippet":"lemma mem_rangeFinset {n : Nat} (τ : Fin n → V) (i : Fin n) : τ i ∈ rangeFinset (V := V) τ := by\n  classical\n  refine Finset.mem_image.2 ?_\n  exact ⟨i, by simp, rfl⟩\n\n/-- Cross-disjointness: the ranges of `τ₁` and `τ₂` do not overlap pointwise. -/","pos":{"x":0.7110160963045117,"y":0.6365704267523865},"pos3":{"x":0.6539343539722425,"y":0.46428310343333085,"z":0.7832852388281509}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.CrossDisjoint","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.CrossDisjoint","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":120,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":1,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":79},"snippet":"def CrossDisjoint {n : Nat} (τ₁ τ₂ : Fin n → V) : Prop :=\n  ∀ i j, τ₁ i ≠ τ₂ j\n","pos":{"x":0.8571440784911174,"y":0.8220555135406178},"pos3":{"x":0.23387248262226382,"y":0.849648483490281,"z":0.6191371974829111}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.crossDisjoint_of_not_mem_range","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.crossDisjoint_of_not_mem_range","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":123,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":1,"exists":0,"eq":0,"tactics":3,"parenDepth":2,"length":371},"snippet":"lemma crossDisjoint_of_not_mem_range {n : Nat} {τ₁ τ₂ : Fin n → V}\n    (h : ∀ j, τ₂ j ∉ rangeFinset (V := V) τ₁) : CrossDisjoint (V := V) τ₁ τ₂ := by\n  intro i j hij\n  have : τ₂ j ∈ rangeFinset (V := V) τ₁ := by\n    simpa [hij] using mem_rangeFinset (V := V) τ₁ i\n  exact (h j this).elim","pos":{"x":0.8331790978784385,"y":0.8297279145831143},"pos3":{"x":0.2079589147913634,"y":0.8517537416581279,"z":0.5605087133551357}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":131,"family":"SystemFresh","features":{"implies":4,"not":0,"and":0,"or":0,"forall":1,"exists":0,"eq":4,"tactics":0,"parenDepth":2,"length":232},"snippet":"def swapPerm : ∀ {n : Nat}, (Fin n → V) → (Fin n → V) → Equiv.Perm V\n  | 0, _τ₁, _τ₂ => Equiv.refl V\n  | n + 1, τ₁, τ₂ =>\n      (Equiv.swap (τ₁ 0) (τ₂ 0)).trans <|\n        swapPerm (n := n) (fun i => τ₁ i.succ) (fun i => τ₂ i.succ)\n","pos":{"x":0.9899672872883599,"y":0.6949784408994922},"pos3":{"x":0.4190062011742769,"y":0.82512548615946,"z":0.7469874035416193}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm_apply_of_forall_ne","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm_apply_of_forall_ne","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":137,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":4,"exists":0,"eq":10,"tactics":7,"parenDepth":1,"length":670},"snippet":"lemma swapPerm_apply_of_forall_ne {n : Nat} {τ₁ τ₂ : Fin n → V} {x : V}\n    (h₁ : ∀ i, x ≠ τ₁ i) (h₂ : ∀ i, x ≠ τ₂ i) :\n    swapPerm τ₁ τ₂ x = x := by\n  induction n generalizing x with\n  | zero =>\n      simp [swapPerm]","pos":{"x":0.7082395076003859,"y":1},"pos3":{"x":0.021114298440732072,"y":0.6789472636776018,"z":0.5538692696121509}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm_apply_left","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm_apply_left","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":153,"family":"SystemFresh","features":{"implies":1,"not":0,"and":1,"or":0,"forall":2,"exists":0,"eq":24,"tactics":34,"parenDepth":2,"length":2445},"snippet":"lemma swapPerm_apply_left {n : Nat} {τ₁ τ₂ : Fin n → V}\n    (hτ₁ : Function.Injective τ₁) (hτ₂ : Function.Injective τ₂)\n    (hdis : CrossDisjoint (V := V) τ₁ τ₂) (i : Fin n) :\n    swapPerm τ₁ τ₂ (τ₁ i) = τ₂ i := by\n  induction n with\n  | zero =>","pos":{"x":0.6594375995624312,"y":0.9395017706659494},"pos3":{"x":0.058558603759449684,"y":0.6606297192875299,"z":0.6238738838971094}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm_fix_of_mem_verts","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.swapPerm_fix_of_mem_verts","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":204,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":2,"exists":0,"eq":1,"tactics":4,"parenDepth":2,"length":450},"snippet":"lemma swapPerm_fix_of_mem_verts {n : Nat} {τ₁ τ₂ : Fin n → V} {s : HGraph V}\n    (hτ₁ : ∀ i, τ₁ i ∉ HGraph.verts (V := V) s)\n    (hτ₂ : ∀ i, τ₂ i ∉ HGraph.verts (V := V) s)\n    {x : V} (hx : x ∈ HGraph.verts (V := V) s) :\n    swapPerm τ₁ τ₂ x = x := by\n  refine swapPerm_apply_of_forall_ne (V := V) (τ₁ := τ₁) (τ₂ := τ₂) (x := x) ?_ ?_","pos":{"x":0.8279908523845273,"y":0.9135322454333101},"pos3":{"x":0.17736305637049235,"y":0.802363747810153,"z":0.535613126575554}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.expr_rename_eq_self_of_forall_mem","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.expr_rename_eq_self_of_forall_mem","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":216,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":2,"exists":0,"eq":7,"tactics":8,"parenDepth":1,"length":471},"snippet":"private lemma expr_rename_eq_self_of_forall_mem (f : V → V) (e : Expr V) (h : ∀ x ∈ e, f x = x) :\n    Expr.rename f e = e := by\n  induction e with\n  | nil =>\n      simp [Expr.rename]\n  | cons a e ih =>","pos":{"x":0.7361934095752511,"y":0.9895538690251763},"pos3":{"x":0.05306393067479781,"y":0.7099109851601092,"z":0.5919319134202892}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.hgraph_rename_eq_self_of_forall_mem","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.hgraph_rename_eq_self_of_forall_mem","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":230,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":2,"exists":0,"eq":9,"tactics":10,"parenDepth":1,"length":667},"snippet":"private lemma hgraph_rename_eq_self_of_forall_mem (f : V → V) (g : HGraph V)\n    (h : ∀ e ∈ g, Expr.rename f e = e) : HGraph.rename f g = g := by\n  classical\n  induction g using Multiset.induction_on with\n  | empty =>\n      simp [HGraph.rename]","pos":{"x":0.6940104417215074,"y":0.9440153837163158},"pos3":{"x":0.0668970124488829,"y":0.6982290304717454,"z":0.5839828927081365}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.hgraph_rename_eq_self_of_fix_verts","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.hgraph_rename_eq_self_of_fix_verts","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":248,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":1,"exists":0,"eq":2,"tactics":6,"parenDepth":2,"length":426},"snippet":"private lemma hgraph_rename_eq_self_of_fix_verts (f : V → V) (s : HGraph V)\n    (hfix : ∀ x ∈ HGraph.verts (V := V) s, f x = x) : HGraph.rename f s = s := by\n  apply hgraph_rename_eq_self_of_forall_mem (V := V) (f := f) (g := s)\n  intro e he\n  apply expr_rename_eq_self_of_forall_mem (V := V) (f := f) (e := e)\n  intro x hx","pos":{"x":0.874252397752068,"y":0.8778216561089333},"pos3":{"x":0.28477837913989473,"y":0.8301683327350486,"z":0.5606568632213664}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.hgraph_rename_eq_self_of_le","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.hgraph_rename_eq_self_of_le","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":257,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":1,"exists":0,"eq":2,"tactics":8,"parenDepth":2,"length":617},"snippet":"private lemma hgraph_rename_eq_self_of_le (f : V → V) {t s : HGraph V} (ht : t ≤ s)\n    (hfix : ∀ x ∈ HGraph.verts (V := V) s, f x = x) : HGraph.rename f t = t := by\n  apply hgraph_rename_eq_self_of_forall_mem (V := V) (f := f) (g := t)\n  intro e he\n  have he' : e ∈ s := Multiset.mem_of_le ht he\n  have := hgraph_rename_eq_self_of_fix_verts (V := V) (f := f) (s := s) hfix","pos":{"x":0.8184002343715945,"y":0.869720007182878},"pos3":{"x":0.25766338718839976,"y":0.7863667700016298,"z":0.5630099702416876}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.sigma_mem_verts_of_inLhs","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.sigma_mem_verts_of_inLhs","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":269,"family":"SystemFresh","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":1,"eq":1,"tactics":4,"parenDepth":2,"length":673},"snippet":"private lemma sigma_mem_verts_of_inLhs (e : sys.Event) {s : HGraph V} (happ : e.Applicable s)\n    {p : P} (hp : ∃ ex ∈ (e.rule.lhs), p ∈ ex) : e.σ p ∈ HGraph.verts (V := V) s := by\n  rcases hp with ⟨ex, hex, hp⟩\n  have hexInput : Expr.rename e.σ ex ∈ e.input (sys := sys) := by\n    -- `input = rename σ lhs`\n    simpa [SystemFresh.Event.input, RuleFresh.instLhs, HGraph.rename] using","pos":{"x":0.7292063969633314,"y":0.015460121552083539},"pos3":{"x":0.8158205288051826,"y":0.7149272445767532,"z":0.0162574631946423}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.sigma_fixed_of_inRhs","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.sigma_fixed_of_inRhs","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":281,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":2,"exists":2,"eq":1,"tactics":2,"parenDepth":2,"length":689},"snippet":"private lemma sigma_fixed_of_inRhs (e : sys.Event) {s : HGraph V} (happ : e.Applicable s)\n    (hwell : (e.rule).WellFormed) {p : P}\n    (hpRhs : ∃ ex ∈ (e.rule.rhs), (Sum.inl p) ∈ ex)\n    {n : Nat} {τ₁ τ₂ : Fin n → V} (hτ₁ : ∀ i, τ₁ i ∉ HGraph.verts (V := V) s)\n    (hτ₂ : ∀ i, τ₂ i ∉ HGraph.verts (V := V) s) :\n    swapPerm τ₁ τ₂ (e.σ p) = e.σ p := by","pos":{"x":0.6806848745623155,"y":0.8377434625594681},"pos3":{"x":0.22934342774181266,"y":0.5947175307756736,"z":0.5252320391554427}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith_rename_of_crossDisjoint","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith_rename_of_crossDisjoint","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":292,"family":"SystemFresh","features":{"implies":2,"not":0,"and":1,"or":0,"forall":3,"exists":2,"eq":19,"tactics":22,"parenDepth":3,"length":4009},"snippet":"lemma applyWith_rename_of_crossDisjoint (e : sys.Event) {s : HGraph V}\n    (happ : e.Applicable s) (hwell : (e.rule).WellFormed)\n    {τ₁ τ₂ : Fin (e.rule.nFresh) → V}\n    (hτ₁ : e.FreshAssign τ₁ s) (hτ₂ : e.FreshAssign τ₂ s)\n    (hdis : CrossDisjoint (V := V) τ₁ τ₂) :\n    HGraph.rename (swapPerm τ₁ τ₂) (e.applyWith τ₁ s) = e.applyWith τ₂ s := by","pos":{"x":0.6751950487285407,"y":0.861796863394316},"pos3":{"x":0.18638433368130838,"y":0.6057042395250176,"z":0.5542762094500412}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith_iso_of_crossDisjoint","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith_iso_of_crossDisjoint","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":382,"family":"SystemFresh","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":445},"snippet":"lemma applyWith_iso_of_crossDisjoint (e : sys.Event) {s : HGraph V}\n    (happ : e.Applicable s) (hwell : (e.rule).WellFormed)\n    {τ₁ τ₂ : Fin (e.rule.nFresh) → V}\n    (hτ₁ : e.FreshAssign τ₁ s) (hτ₂ : e.FreshAssign τ₂ s)\n    (hdis : CrossDisjoint (V := V) τ₁ τ₂) :\n    HGraph.Iso (e.applyWith τ₁ s) (e.applyWith τ₂ s) := by","pos":{"x":0.8172410039711732,"y":0.5183369404444856},"pos3":{"x":0.6622529401929298,"y":0.7726269628288086,"z":0.651248821894806}},{"id":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith_iso","name":"HeytingLean.WPP.Wolfram.SystemFresh.Event.applyWith_iso","kind":"lemma","path":"RESEARCHER_BUNDLE/HeytingLean/WPP/Wolfram/RewriteFresh.lean","line":391,"family":"SystemFresh","features":{"implies":2,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":33,"parenDepth":2,"length":2298},"snippet":"lemma applyWith_iso (e : sys.Event) [FreshSupply V] {s : HGraph V}\n    (happ : e.Applicable s) (hwell : (e.rule).WellFormed)\n    {τ₁ τ₂ : Fin (e.rule.nFresh) → V}\n    (hτ₁ : e.FreshAssign τ₁ s) (hτ₂ : e.FreshAssign τ₂ s) :\n    HGraph.Iso (e.applyWith τ₁ s) (e.applyWith τ₂ s) := by\n  classical","pos":{"x":0.9578636280247746,"y":0.5796219877044008},"pos3":{"x":0.6128262071277246,"y":0.8446913126871264,"z":0.7922028483167072}},{"id":"HeytingLean.CLI.WolframWM148.Args","name":"HeytingLean.CLI.WolframWM148.Args","kind":"structure","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":24,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":0,"length":62},"snippet":"structure Args where\n  maxDepth : Nat := 6\nderiving Inhabited\n","pos":{"x":0.04996080574091636,"y":0.6435358625266087},"pos3":{"x":0.748785725126815,"y":0.027546690942476436,"z":0.9808983937423424}},{"id":"HeytingLean.CLI.WolframWM148.parseArg","name":"HeytingLean.CLI.WolframWM148.parseArg","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":28,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":4,"tactics":0,"parenDepth":1,"length":191},"snippet":"private def parseArg (xs : List String) (flag : String) : Option String :=\n  match xs with\n  | [] => none\n  | x::y::rest => if x = flag then some y else parseArg (y::rest) flag\n  | _ => none\n","pos":{"x":0.03256594928419875,"y":0.8485093981840823},"pos3":{"x":0.8560172302465613,"y":0.19705388643748428,"z":0.8737847903108952}},{"id":"HeytingLean.CLI.WolframWM148.parseArgs","name":"HeytingLean.CLI.WolframWM148.parseArgs","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":34,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":163},"snippet":"private def parseArgs (argv : List String) : Args :=\n  let maxDepth := (parseArg argv \"--maxDepth\").bind (·.toNat?) |>.getD 6\n  {maxDepth}\n\n/-! ## JSON helpers -/\n","pos":{"x":0.16081889764870821,"y":0.8077961529277717},"pos3":{"x":0.7293621756794982,"y":0.22146848167518798,"z":0.851208423323222}},{"id":"HeytingLean.CLI.WolframWM148.exprToJsonNat","name":"HeytingLean.CLI.WolframWM148.exprToJsonNat","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":40,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":0,"parenDepth":2,"length":111},"snippet":"private def exprToJsonNat (e : Wolfram.Expr Nat) : Json :=\n  Json.arr (e.map (fun v => Json.num v) |>.toArray)\n","pos":{"x":0.5786360460122558,"y":0.04270422297754519},"pos3":{"x":0.9127775865600839,"y":0.8007314982397452,"z":0.08865677641745011}},{"id":"HeytingLean.CLI.WolframWM148.sigmaFin2ToJsonNat","name":"HeytingLean.CLI.WolframWM148.sigmaFin2ToJsonNat","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":43,"family":"CLI.WolframWM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":104},"snippet":"private def sigmaFin2ToJsonNat (σ : Fin 2 → Nat) : Json :=\n  Json.arr #[Json.num (σ 0), Json.num (σ 1)]\n","pos":{"x":0.8002398972991489,"y":0.654412635284998},"pos3":{"x":0.5816842836474668,"y":0.5704655501746229,"z":0.7149342494544534}},{"id":"HeytingLean.CLI.WolframWM148.mkBasisLen1Len2Nat","name":"HeytingLean.CLI.WolframWM148.mkBasisLen1Len2Nat","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":46,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":2,"length":347},"snippet":"private def mkBasisLen1Len2Nat (maxVertex : Nat) : Array (Wolfram.Expr Nat) :=\n  Id.run do\n    let verts : Array Nat := (List.range (maxVertex + 1)).toArray\n    let mut out : Array (Wolfram.Expr Nat) := #[]\n    for v in verts do\n      out := out.push [v]","pos":{"x":0.6488619645965962,"y":0.06200970419327757},"pos3":{"x":0.9753769134590801,"y":0.7383040518216865,"z":0.07287062555435897}},{"id":"HeytingLean.CLI.WolframWM148.stateToCountsJsonNat","name":"HeytingLean.CLI.WolframWM148.stateToCountsJsonNat","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":57,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":0,"parenDepth":3,"length":200},"snippet":"private def stateToCountsJsonNat (basis : Array (Wolfram.Expr Nat)) (g : Wolfram.HGraph Nat) : Json :=\n  Json.arr (basis.map (fun e => Json.num (g.count e)))\n\n/-! ## Multiway exploration (bounded) -/\n","pos":{"x":0.9351383823974129,"y":0.17585990374624025},"pos3":{"x":0.9140377463280156,"y":0.9344613418831503,"z":0.3363132352727763}},{"id":"HeytingLean.CLI.WolframWM148.findIdxFuel","name":"HeytingLean.CLI.WolframWM148.findIdxFuel","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":62,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":3,"tactics":0,"parenDepth":1,"length":279},"snippet":"private def findIdxFuel {α : Type} [DecidableEq α] (arr : Array α) (x : α) (fuel i : Nat) : Option Nat :=\n  match fuel with\n  | 0 => none\n  | fuel + 1 =>\n      if h : i < arr.size then\n        if arr[i] = x then some i else findIdxFuel arr x fuel (i + 1)","pos":{"x":0,"y":0.83454795693937},"pos3":{"x":0.8405398183822571,"y":0.15166896293177234,"z":0.907994924301234}},{"id":"HeytingLean.CLI.WolframWM148.findIdx","name":"HeytingLean.CLI.WolframWM148.findIdx","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":71,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":124},"snippet":"private def findIdx {α : Type} [DecidableEq α] (arr : Array α) (x : α) : Option Nat :=\n  findIdxFuel arr x (arr.size + 1) 0\n","pos":{"x":0.16642477948194845,"y":0.7752159691788586},"pos3":{"x":0.7919266176927331,"y":0.19297725648589187,"z":0.8225274482898284}},{"id":"HeytingLean.CLI.WolframWM148.getIdx","name":"HeytingLean.CLI.WolframWM148.getIdx","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":74,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":2,"tactics":0,"parenDepth":1,"length":186},"snippet":"private def getIdx {α : Type} [DecidableEq α] (nodes : Array α) (x : α) : (Array α × Nat) :=\n  match findIdx nodes x with\n  | some i => (nodes, i)\n  | none => (nodes.push x, nodes.size)\n","pos":{"x":0.038591776183693444,"y":0.8311428914975373},"pos3":{"x":0.809509735145958,"y":0.18769869091564467,"z":0.925195934304236}},{"id":"HeytingLean.CLI.WolframWM148.dedupArray","name":"HeytingLean.CLI.WolframWM148.dedupArray","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":79,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":1,"tactics":0,"parenDepth":2,"length":173},"snippet":"private def dedupArray {α : Type} [DecidableEq α] (xs : Array α) : Array α :=\n  xs.foldl (init := (#[] : Array α)) (fun acc x => if acc.contains x then acc else acc.push x)\n","pos":{"x":0.6143772426067587,"y":0.05450613208846817},"pos3":{"x":0.9017908074614517,"y":0.7458864751824617,"z":0.108851117656419}},{"id":"HeytingLean.CLI.WolframWM148.buildWM148Multiway","name":"HeytingLean.CLI.WolframWM148.buildWM148Multiway","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":82,"family":"CLI.WolframWM148","features":{"implies":1,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":4,"tactics":1,"parenDepth":5,"length":2548},"snippet":"private def buildWM148Multiway (maxDepth : Nat) : Json := Id.run do\n  let sys := Wolfram.WM148.sys\n  let mut nodes : Array (Wolfram.HGraph Nat) := #[sys.init]\n  let mut edges : Array Json := #[]\n  let mut levels : Array (Array Nat) := #[#[0]]\n","pos":{"x":0.9042328292648064,"y":0.2799649292552932},"pos3":{"x":0.8509499039505691,"y":0.9448795377590723,"z":0.433884236118586}},{"id":"HeytingLean.CLI.WolframWM148.run","name":"HeytingLean.CLI.WolframWM148.run","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":155,"family":"CLI.WolframWM148","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":195},"snippet":"def run (argv : List String) : IO Unit := do\n  let args := parseArgs argv\n  let payload := buildWM148Multiway args.maxDepth\n  IO.println payload.pretty\n\nend WolframWM148","pos":{"x":0.14867245193634226,"y":0.8022783091765733},"pos3":{"x":0.6637091213027803,"y":0.1569924644015797,"z":0.8794670511777426}},{"id":"main","name":"main","kind":"def","path":"RESEARCHER_BUNDLE/HeytingLean/CLI/WolframWM148Main.lean","line":165,"family":"Other","features":{"implies":0,"not":0,"and":0,"or":0,"forall":0,"exists":0,"eq":0,"tactics":0,"parenDepth":1,"length":83},"snippet":"def main (argv : List String) : IO Unit :=\n  HeytingLean.CLI.WolframWM148.run argv\n","pos":{"x":0.1618593485873167,"y":0.8541667192360635},"pos3":{"x":0.707126790744666,"y":0.22801075338498122,"z":0.8380595201500601}}],"edges":[[0,1],[0,3],[0,64],[0,6],[0,49],[1,3],[1,64],[1,6],[1,49],[2,13],[2,74],[2,30],[2,12],[2,17],[3,64],[3,6],[3,49],[4,12],[4,66],[4,17],[4,74],[5,41],[5,57],[5,31],[5,16],[5,42],[6,64],[6,49],[6,77],[6,47],[7,58],[7,32],[7,18],[7,15],[7,59],[8,35],[8,67],[8,68],[8,47],[8,72],[9,40],[9,48],[9,28],[9,29],[9,71],[10,37],[10,33],[10,60],[10,23],[10,59],[11,72],[11,67],[11,35],[11,20],[12,17],[12,66],[12,74],[13,30],[13,74],[13,73],[14,55],[14,54],[14,62],[14,16],[14,57],[15,56],[15,32],[15,52],[15,59],[15,58],[16,57],[16,31],[16,54],[16,62],[16,42],[17,74],[17,66],[18,19],[18,38],[18,58],[18,55],[19,38],[19,58],[19,55],[20,72],[20,66],[20,67],[21,34],[21,45],[21,39],[21,27],[21,26],[22,69],[22,46],[22,50],[22,36],[22,41],[23,24],[23,37],[23,33],[23,60],[24,37],[24,33],[24,60],[25,61],[25,75],[25,53],[25,63],[26,39],[26,70],[26,34],[26,76],[27,45],[27,44],[27,51],[27,34],[27,29],[28,29],[28,48],[28,44],[29,48],[29,44],[29,51],[30,73],[30,74],[31,57],[31,42],[31,62],[32,56],[32,59],[32,52],[32,58],[33,60],[33,59],[33,52],[33,56],[34,39],[34,45],[34,44],[35,67],[35,68],[35,47],[35,72],[36,43],[36,69],[36,46],[36,71],[37,60],[37,59],[37,52],[38,55],[38,54],[38,62],[39,70],[39,76],[40,71],[40,48],[41,42],[41,57],[41,50],[42,57],[42,62],[43,71],[43,69],[43,46],[44,45],[44,51],[45,51],[46,69],[46,50],[47,68],[47,67],[47,77],[49,77],[49,64],[49,68],[50,69],[52,56],[52,59],[52,60],[53,75],[53,63],[53,61],[54,62],[54,57],[54,55],[55,62],[56,59],[56,60],[58,59],[59,60],[61,75],[61,63],[63,75],[64,77],[65,73],[65,76],[65,70],[66,74],[67,68],[67,72],[68,72],[70,76],[70,73],[73,76],[73,74]],"edgesSemantic":[]};