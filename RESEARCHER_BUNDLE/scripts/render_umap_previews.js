#!/usr/bin/env node
"use strict";

/**
 * Render static SVG previews for the Wolfram proof/declaration UMAP embedding.
 *
 * Inputs:
 *   - artifacts/visuals/wolfram_proofs.json (generated by the visualization toolchain)
 *
 * Outputs:
 *   - artifacts/visuals/wolfram_2d_preview.svg
 *   - artifacts/visuals/wolfram_3d_preview.svg
 *
 * This is intentionally dependency-free (Node stdlib only), so that the bundle remains easy
 * to reproduce in hostile environments.
 */

const fs = require("fs");
const path = require("path");

function fail(msg) {
  console.error(`E: ${msg}`);
  process.exit(1);
}

function hash32(s) {
  // FNV-1a 32-bit
  let h = 0x811c9dc5;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}

function colorForFamily(family) {
  const h = hash32(family) % 360;
  return {
    fill: `hsl(${h} 70% 58%)`,
    stroke: `hsl(${h} 70% 32%)`,
  };
}

function esc(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function svgDoc({ width, height, background, body }) {
  return `<?xml version="1.0" encoding="utf-8"?>\n` +
    `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" ` +
    `viewBox="0 0 ${width} ${height}" role="img" aria-label="UMAP preview">\n` +
    `<rect x="0" y="0" width="${width}" height="${height}" fill="${background}"/>\n` +
    `${body}\n` +
    `</svg>\n`;
}

function renderLegend({ families, counts, x, y, lineH }) {
  const entries = [...families].sort((a, b) => (counts.get(b) ?? 0) - (counts.get(a) ?? 0));
  let out = "";
  let cy = y;
  for (const fam of entries) {
    const n = counts.get(fam) ?? 0;
    const c = colorForFamily(fam);
    out += `<rect x="${x}" y="${cy}" width="10" height="10" fill="${c.fill}" stroke="${c.stroke}" stroke-width="1"/>\n`;
    out += `<text x="${x + 16}" y="${cy + 9}" fill="#e6eef7" font-size="12" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">${esc(fam)} <tspan fill="#b8c7d9">(${n})</tspan></text>\n`;
    cy += lineH;
  }
  return out;
}

function map2dPoints({ items, getPos, width, height, margin, plotW, plotH }) {
  function toCanvas(p) {
    const x = margin + p.x * plotW;
    const y = margin + (1 - p.y) * plotH;
    return { x, y };
  }
  return items.map((it) => toCanvas(getPos(it)));
}

function render2d({ data, outPath }) {
  const items = data.items ?? [];
  const edges = data.edges ?? [];

  const width = 1500;
  const height = 900;
  const background = "#0b0f14";

  const margin = 50;
  const legendW = 310;
  const plotW = width - margin * 2 - legendW;
  const plotH = height - margin * 2;
  const legendX = margin + plotW + 30;

  const counts = new Map();
  for (const it of items) {
    const fam = it.family ?? "Other";
    counts.set(fam, (counts.get(fam) ?? 0) + 1);
  }
  const families = [...counts.keys()];

  const pts = map2dPoints({
    items,
    getPos: (it) => it.pos,
    width,
    height,
    margin,
    plotW,
    plotH,
  });

  let body = "";
  body += `<text x="${margin}" y="${margin - 18}" fill="#ffffff" font-size="20" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">UMAP 2D — Wolfram/WPP proof/declaration map</text>\n`;
  body += `<text x="${margin}" y="${margin - 2}" fill="#b8c7d9" font-size="12" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">Points: declarations • Colors: module family • Edges: kNN similarity links (source-text features)</text>\n`;

  body += `<rect x="${margin}" y="${margin}" width="${plotW}" height="${plotH}" fill="#0f1721" stroke="#1c2a3a" stroke-width="1"/>\n`;

  // Edges (light)
  for (const [i, j] of edges) {
    const a = pts[i];
    const b = pts[j];
    if (!a || !b) continue;
    body += `<line x1="${a.x.toFixed(2)}" y1="${a.y.toFixed(2)}" x2="${b.x.toFixed(2)}" y2="${b.y.toFixed(2)}" stroke="#3b4b5d" stroke-opacity="0.18" stroke-width="1"/>\n`;
  }

  // Nodes
  for (let idx = 0; idx < items.length; idx++) {
    const it = items[idx];
    const p = pts[idx];
    if (!p) continue;
    const fam = it.family ?? "Other";
    const c = colorForFamily(fam);
    body += `<circle cx="${p.x.toFixed(2)}" cy="${p.y.toFixed(2)}" r="4" fill="${c.fill}" stroke="#0b0f14" stroke-width="1">\n`;
    body += `  <title>${esc(it.name ?? it.id ?? "item")}</title>\n`;
    body += `</circle>\n`;
  }

  // Legend
  body += `<text x="${legendX}" y="${margin}" fill="#ffffff" font-size="16" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">Legend</text>\n`;
  body += renderLegend({ families, counts, x: legendX, y: margin + 14, lineH: 16 });

  const svg = svgDoc({ width, height, background, body });
  fs.writeFileSync(outPath, svg, "utf8");
}

function rotateX([x, y, z], a) {
  const ca = Math.cos(a);
  const sa = Math.sin(a);
  return [x, y * ca - z * sa, y * sa + z * ca];
}

function rotateY([x, y, z], a) {
  const ca = Math.cos(a);
  const sa = Math.sin(a);
  return [x * ca + z * sa, y, -x * sa + z * ca];
}

function render3d({ data, outPath }) {
  const items = data.items ?? [];
  const edges = data.edges ?? [];

  const width = 1500;
  const height = 900;
  const background = "#0b0f14";

  const margin = 50;
  const legendW = 310;
  const plotW = width - margin * 2 - legendW;
  const plotH = height - margin * 2;
  const legendX = margin + plotW + 30;

  const yaw = 0.75;
  const pitch = 0.48;
  const cameraDist = 3.0;

  const counts = new Map();
  for (const it of items) {
    const fam = it.family ?? "Other";
    counts.set(fam, (counts.get(fam) ?? 0) + 1);
  }
  const families = [...counts.keys()];

  // Rotate + perspective project into an intermediate 2D plane.
  const proj = items.map((it) => {
    const p3 = it.pos3;
    if (!p3) return null;
    let x = (p3.x - 0.5) * 2.0;
    let y = (p3.y - 0.5) * 2.0;
    let z = (p3.z - 0.5) * 2.0;
    let v = [x, y, z];
    v = rotateY(v, yaw);
    v = rotateX(v, pitch);
    const [rx, ry, rz] = v;
    const s = cameraDist / (cameraDist - rz);
    return { x: rx * s, y: ry * s, z: rz };
  });

  // Normalize projected coordinates to [0,1] for plotting.
  const xs = proj.filter(Boolean).map((p) => p.x);
  const ys = proj.filter(Boolean).map((p) => p.y);
  const zs = proj.filter(Boolean).map((p) => p.z);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const minZ = Math.min(...zs), maxZ = Math.max(...zs);

  function norm(p) {
    const nx = (p.x - minX) / (maxX - minX || 1);
    const ny = (p.y - minY) / (maxY - minY || 1);
    const nz = (p.z - minZ) / (maxZ - minZ || 1);
    return { x: nx, y: ny, z: nz };
  }

  const pts = proj.map((p) => (p ? norm(p) : null));

  function toCanvas(p) {
    const x = margin + p.x * plotW;
    const y = margin + (1 - p.y) * plotH;
    return { x, y, z: p.z };
  }

  const canvasPts = pts.map((p) => (p ? toCanvas(p) : null));

  let body = "";
  body += `<text x="${margin}" y="${margin - 18}" fill="#ffffff" font-size="20" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">UMAP 3D — Wolfram/WPP proof/declaration map (static projection)</text>\n`;
  body += `<text x="${margin}" y="${margin - 2}" fill="#b8c7d9" font-size="12" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">Perspective projection of UMAP 3D coordinates • Nearer points are slightly larger</text>\n`;

  body += `<rect x="${margin}" y="${margin}" width="${plotW}" height="${plotH}" fill="#0f1721" stroke="#1c2a3a" stroke-width="1"/>\n`;

  // Edges (light; draw before nodes).
  for (const [i, j] of edges) {
    const a = canvasPts[i];
    const b = canvasPts[j];
    if (!a || !b) continue;
    const depth = ((a.z ?? 0) + (b.z ?? 0)) / 2;
    const alpha = (0.10 + 0.22 * depth).toFixed(3);
    body += `<line x1="${a.x.toFixed(2)}" y1="${a.y.toFixed(2)}" x2="${b.x.toFixed(2)}" y2="${b.y.toFixed(2)}" stroke="#3b4b5d" stroke-opacity="${alpha}" stroke-width="1"/>\n`;
  }

  // Nodes: draw far-to-near for nicer occlusion.
  const order = [...items.keys()].sort((i, j) => {
    const zi = canvasPts[i]?.z ?? 0;
    const zj = canvasPts[j]?.z ?? 0;
    return zi - zj;
  });

  for (const idx of order) {
    const it = items[idx];
    const p = canvasPts[idx];
    if (!p) continue;
    const fam = it.family ?? "Other";
    const c = colorForFamily(fam);
    const r = 3 + 3 * (p.z ?? 0);
    body += `<circle cx="${p.x.toFixed(2)}" cy="${p.y.toFixed(2)}" r="${r.toFixed(2)}" fill="${c.fill}" stroke="#0b0f14" stroke-width="1">\n`;
    body += `  <title>${esc(it.name ?? it.id ?? "item")}</title>\n`;
    body += `</circle>\n`;
  }

  body += `<text x="${legendX}" y="${margin}" fill="#ffffff" font-size="16" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial">Legend</text>\n`;
  body += renderLegend({ families, counts, x: legendX, y: margin + 14, lineH: 16 });

  const svg = svgDoc({ width, height, background, body });
  fs.writeFileSync(outPath, svg, "utf8");
}

function main() {
  const root = path.resolve(__dirname, "..");
  const jsonPath =
    process.argv[2] ??
    path.join(root, "artifacts", "visuals", "wolfram_proofs.json");

  const out2d =
    process.argv[3] ??
    path.join(root, "artifacts", "visuals", "wolfram_2d_preview.svg");

  const out3d =
    process.argv[4] ??
    path.join(root, "artifacts", "visuals", "wolfram_3d_preview.svg");

  if (!fs.existsSync(jsonPath)) {
    fail(`missing input: ${jsonPath}`);
  }

  const raw = fs.readFileSync(jsonPath, "utf8");
  const data = JSON.parse(raw);
  if (!Array.isArray(data.items)) {
    fail(`expected JSON to have array field: items`);
  }

  render2d({ data, outPath: out2d });
  render3d({ data, outPath: out3d });

  console.log(`[render_umap_previews] wrote:\n- ${out2d}\n- ${out3d}`);
}

main();

